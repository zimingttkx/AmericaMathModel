[{"cell_type": "markdown", "metadata": {}, "source": ["# 方案C: 遗传算法模型", "", "## 思路", "随机生成粉丝投票数据，模拟比赛规则，通过进化找到最符合历史数据的投票分布。", "", "## 算法流程", "1. 初始化种群（随机粉丝投票分布）", "2. 计算适应度（与真实淘汰结果的匹配程度）", "3. 选择、交叉、变异", "4. 迭代直到收敛"]}, {"cell_type": "markdown", "metadata": {}, "source": ["## 1. 环境配置"]}, {"cell_type": "code", "metadata": {}, "source": ["import pandas as pd", "import numpy as np", "from scipy import stats", "import matplotlib.pyplot as plt", "import warnings", "warnings.filterwarnings('ignore')", "", "np.random.seed(42)", "plt.rcParams[\"font.sans-serif\"] = [\"SimHei\", \"DejaVu Sans\"]", "plt.rcParams[\"axes.unicode_minus\"] = False", "COLORS = [\"#E64B35\", \"#4DBBD5\", \"#00A087\", \"#3C5488\", \"#F39B7F\"]", "print('环境配置完成')"], "outputs": [], "execution_count": null}, {"cell_type": "markdown", "metadata": {}, "source": ["## 2. 加载数据"]}, {"cell_type": "code", "metadata": {}, "source": ["df = pd.read_excel('../../data/processed/粉丝投票分析.xlsx')", "print(f'数据维度: {df.shape}')"], "outputs": [], "execution_count": null}, {"cell_type": "markdown", "metadata": {}, "source": ["## 3. 数据预处理"]}, {"cell_type": "code", "metadata": {}, "source": ["def get_scoring_method(season):", "    if season <= 2:", "        return 'ranking_early'", "    elif season <= 27:", "        return 'percentage'", "    else:", "        return 'ranking_with_save'", "", "def prepare_week_data(df, season, week):", "    week_df = df[(df['赛季'] == season) & (df['第几周'] == week)].copy()", "    week_df = week_df[week_df['本周评委总分'] > 0]", "    ", "    if len(week_df) == 0:", "        return None", "    ", "    scoring_method = get_scoring_method(season)", "    method = 1 if scoring_method == 'percentage' else 0", "    ", "    return {", "        'contestants': week_df['选手姓名'].tolist(),", "        'judge_scores': week_df['本周评委总分'].values,", "        'judge_pct': week_df['评委百分比'].values,", "        'eliminated': week_df[week_df['是否被淘汰'] == 1]['选手姓名'].tolist(),", "        'scoring_method': scoring_method,", "        'method': method,", "        'n_contestants': len(week_df)", "    }", "", "print('数据预处理函数定义完成')"], "outputs": [], "execution_count": null}, {"cell_type": "markdown", "metadata": {}, "source": ["## 4. 适应度函数"]}, {"cell_type": "code", "metadata": {}, "source": ["def fitness(individual, week_data):", "    contestants = week_data['contestants']", "    judge_pct = week_data['judge_pct']", "    judge_scores = week_data['judge_scores']", "    eliminated = week_data['eliminated']", "    method = week_data['method']", "    n = len(contestants)", "    ", "    if len(eliminated) == 0:", "        return 1.0", "    ", "    fan_pct = individual / np.sum(individual) * 100", "    ", "    if method == 1:", "        total_scores = judge_pct + fan_pct", "    else:", "        judge_rank = stats.rankdata(-judge_scores)", "        fan_rank = stats.rankdata(-fan_pct)", "        total_scores = -(judge_rank + fan_rank)", "    ", "    elim_idx = [contestants.index(e) for e in eliminated if e in contestants]", "    sorted_idx = np.argsort(total_scores)", "    predicted_elim_idx = sorted_idx[:len(eliminated)]", "    ", "    correct = sum(1 for e in elim_idx if e in predicted_elim_idx)", "    fitness_score = correct / len(eliminated)", "    ", "    for e_idx in elim_idx:", "        rank = np.where(sorted_idx == e_idx)[0][0]", "        fitness_score += (1 - rank / n) * 0.1", "    ", "    return fitness_score", "", "print('适应度函数定义完成')"], "outputs": [], "execution_count": null}, {"cell_type": "markdown", "metadata": {}, "source": ["## 5. 遗传算法核心"]}, {"cell_type": "code", "metadata": {}, "source": ["def initialize_population(n_contestants, pop_size):", "    population = []", "    for _ in range(pop_size):", "        individual = np.random.dirichlet(np.ones(n_contestants)) * 100", "        population.append(individual)", "    return np.array(population)", "", "def selection(population, fitness_scores, n_select):", "    probs = fitness_scores / np.sum(fitness_scores)", "    selected_idx = np.random.choice(len(population), size=n_select, p=probs, replace=True)", "    return population[selected_idx]", "", "def crossover(parent1, parent2):", "    alpha = np.random.random()", "    child = alpha * parent1 + (1 - alpha) * parent2", "    return child / np.sum(child) * 100", "", "def mutate(individual, mutation_rate=0.1):", "    if np.random.random() < mutation_rate:", "        noise = np.random.normal(0, 5, len(individual))", "        individual = individual + noise", "        individual = np.maximum(individual, 0)", "        individual = individual / np.sum(individual) * 100", "    return individual", "", "print('遗传算法核心函数定义完成')"], "outputs": [], "execution_count": null}, {"cell_type": "markdown", "metadata": {}, "source": ["## 6. 遗传算法主函数"]}, {"cell_type": "code", "metadata": {}, "source": ["def genetic_algorithm(week_data, pop_size=50, n_generations=100, mutation_rate=0.1):", "    n = len(week_data['contestants'])", "    if n == 0:", "        return None, 0", "    ", "    population = initialize_population(n, pop_size)", "    best_individual = None", "    best_fitness = -np.inf", "    ", "    for gen in range(n_generations):", "        fitness_scores = np.array([fitness(ind, week_data) for ind in population])", "        max_idx = np.argmax(fitness_scores)", "        if fitness_scores[max_idx] > best_fitness:", "            best_fitness = fitness_scores[max_idx]", "            best_individual = population[max_idx].copy()", "        ", "        selected = selection(population, fitness_scores + 0.01, pop_size)", "        new_population = []", "        for i in range(0, pop_size, 2):", "            p1, p2 = selected[i], selected[min(i+1, pop_size-1)]", "            c1 = mutate(crossover(p1, p2), mutation_rate)", "            c2 = mutate(crossover(p2, p1), mutation_rate)", "            new_population.extend([c1, c2])", "        ", "        population = np.array(new_population[:pop_size])", "        population[0] = best_individual", "    ", "    return dict(zip(week_data['contestants'], best_individual)), best_fitness", "", "print('遗传算法主函数定义完成')"], "outputs": [], "execution_count": null}, {"cell_type": "markdown", "metadata": {}, "source": ["## 7. 单元测试"]}, {"cell_type": "code", "metadata": {}, "source": ["print('=' * 60)", "print('单元测试: 第5季第3周')", "print('=' * 60)", "", "week_data = prepare_week_data(df, 5, 3)", "print(f'选手: {week_data[\"contestants\"]}')", "print(f'被淘汰: {week_data[\"eliminated\"]}')", "", "result, best_fit = genetic_algorithm(week_data, pop_size=30, n_generations=50)", "print(f'\\n最优适应度: {best_fit:.4f}')", "print('\\n粉丝投票估算:')", "for name, vote in sorted(result.items(), key=lambda x: -x[1]):", "    print(f'  {name}: {vote:.2f}%')"], "outputs": [], "execution_count": null}, {"cell_type": "markdown", "metadata": {}, "source": ["## 8. 多次运行稳定性分析"]}, {"cell_type": "code", "metadata": {}, "source": ["def ga_multirun_estimates(week_data, n_runs=10, pop_size=30, n_generations=50):", "    all_solutions = []", "    for _ in range(n_runs):", "        result, _ = genetic_algorithm(week_data, pop_size=pop_size, n_generations=n_generations)", "        if result:", "            all_solutions.append(result)", "    ", "    if len(all_solutions) < 2:", "        return None", "    ", "    estimates = {}", "    for c in week_data['contestants']:", "        values = [sol[c] for sol in all_solutions if c in sol]", "        if values:", "            estimates[c] = (min(values), max(values))", "    ", "    return estimates", "", "estimates = ga_multirun_estimates(week_data, n_runs=10)", "print('\\n多次运行范围估计:')", "for name, (lb, ub) in estimates.items():", "    width = ub - lb", "    cert = 1 - width / 100", "    print(f'  {name}: [{lb:.1f}%, {ub:.1f}%], 确定性={cert:.1%}')"], "outputs": [], "execution_count": null}]