# 快速修复与调试 AI Prompt 模板（详细版）

> **使用说明**: 本文件包含代码错误修复、性能优化、调试技巧的详细Prompt模板。

---

## 🐛 场景1: 代码错误修复

### 通用错误修复完整模板

```
我的Python代码报错了，请帮我修复。

【错误信息】
错误类型：【TypeError/ValueError/AttributeError/KeyError/ImportError/...】

完整错误信息：
【请粘贴完整的错误堆栈信息，包括所有Traceback】

【代码】
```python
【请粘贴你的完整代码】
```

【环境信息】
Python版本：【如：3.10.19】
操作系统：【MacOS/Linux/Windows】
已安装的库：【列出主要库】

【错误出现时机】
- 运行时错误：代码执行到某个位置报错
- 导入错误：导入库时报错
- 逻辑错误：运行不报错但结果不对

【期望输出】
1. 错误原因分析（具体是哪行代码、什么原因）
2. 修复后的完整代码
3. 解释修复方法（为什么这样修复）
4. 预防措施（如何避免类似错误）

【示例错误和修复】

错误示例1：
```
错误：IndexError: list index out of range
代码：my_list = [1, 2,3]; value = my_list[5]

修复：索引越界，列表只有3个元素（索引0-2）
解决方案：检查索引范围或添加边界检查
```

错误示例2：
```
错误：KeyError: 'column_name' not in DataFrame
代码：df['column_name']

修复：列名错误，检查实际的列名
解决方案：使用df.columns.tolist()查看所有列名
```

【代码质量要求】
- 提供完整的可运行代码
- 添加详细的中文注释
- 包含错误处理（try-except）
- 添加验证步骤
- 符合PEP8规范
```

### 常见错误速查与修复

#### 类型错误（TypeError）

```
【错误类型】TypeError: 'str' object does not support item assignment

【常见原因】
1. 字符串不可变，尝试修改
   ```python
   # 错误代码
   s = "hello"
   s[0] = "H"  # 错误
   
   # 修复
   s = "hello"
   s = "H" + s[1:]  # 正确
   ```

2. 混合类型运算
   ```python
   # 错误
   result = "5" + 3  # TypeError
   
   # 修复
   result = int("5") + 3
   ```

【完整修复Prompt】
```
请修复以下TypeError错误：

【错误信息】
TypeError: unsupported operand type(s) for +: 'int' and 'str'

【错误代码】
age = input("请输入年龄：")
result = age + 10

【环境】
Python版本：3.x

【要求】
1. 解释错误原因
2. 提供修复后的代码
3. 添加输入验证
4. 添加详细注释

【期望输出】
错误原因：input()返回字符串，不能直接与整数相加
修复代码：
```python
age = input("请输入年龄：")
if age.isdigit():
    result = int(age) + 10
else:
    print("请输入有效的整数！")
```
```

#### 维度错误（ValueError/Shape mismatch）

```
【错误类型】ValueError: operands could not be broadcast together

【常见原因】
数组/矩阵维度不匹配

【完整诊断Prompt】
```
请修复维度错误：

【错误信息】
ValueError: shape (100,) and (100, 50) not aligned

【错误代码】
```python
import numpy as np
a = np.random.rand(100)
b = np.random.rand(100, 50)
c = a + b  # 错误
```

【要求】
1. 分析维度不匹配的原因
2. 提供3种修复方案：
   - 删除多余的维度
   - 扩展较小的维度
   - 使用广播机制
3. 解释每种方案的适用场景
4. 提供完整的可运行代码

【期望输出】
方案1：广播
```python
c = a[:, np.newaxis] + b
```

方案2：删除多余维度
```python
b_squeezed = b.squeeze()  # (100,) 删除单维度
c = a + b_squeezed
```

方案3：填充或切片
```python
b_adjusted = b[:, :50]  # 只取前50列
c = a + b_adjusted
```
```

#### 关键错误（KeyError）

```
【错误类型】KeyError: 'xxx' not found

【完整诊断Prompt】
```
请修复KeyError错误。

【错误信息】
KeyError: 'Age' not found

【错误代码】
df['Age'].mean()  # 错误

【数据框信息】
列名：['age', 'Name', 'Salary']（全小写）

【要求】
1. 检查实际列名
   ```python
   print(df.columns.tolist())
   ```

2. 提供修复代码
   ```python
   # 方法1：修改列名
   df['age']  # 如果列名是小写
   
   # 方法2：重命名列
   df = df.rename(columns={'age': 'Age'})
   ```

3. 添加列名检查
   ```python
   if 'Age' not in df.columns:
       print("警告：列名'Age'不存在，可用列名：")
       print(df.columns.tolist())
   ```

【输出要求】
- 诊断列名不匹配的原因
- 提供修复代码
- 添加预防措施
```

#### 导入错误（ImportError/ModuleNotFoundError）

```
【错误类型】ModuleNotFoundError: No module named 'xxx'

【完整诊断Prompt】
```
请修复导入错误。

【错误信息】
ModuleNotFoundError: No module named 'xgboost'

【环境信息】
Python版本：3.10.19
环境：conda环境，环境名【AmericaMathModel】

【要求】
1. 检查包是否安装
   ```python
   import pip
   installed_packages = pip.list()
   for pkg in installed_packages:
       if 'xgboost' in pkg.name:
           print(f"{pkg.name} {pkg.version}")
   ```

2. 提供安装命令
   ```bash
   # 方法1：使用pip
   pip install xgboost
   
   # 方法2：使用conda
   conda install -c conda-forge xgboost
   
   # 方法3：使用国内镜像加速
   pip install xgboost -i https://pypi.tuna.tsinghua.edu.cn/simple
   ```

3. 验证安装
   ```python
   import xgboost as xgb
   print(f"XGBoost version: {xgb.__version__}")
   ```

【输出要求】
- 诊断未安装的原因
- 提供多个安装方案
- 验证安装是否成功
```

---

## ⚡ 场景2: 性能优化

### 运行速度慢完整优化Prompt

```
我的Python代码运行很慢，请帮我优化。

【代码信息】
```python
【你的完整代码】
```

【性能问题】
- 数据规模：【行数×列数】
- 运行时间：【几分钟/几小时】
- 机器配置：【CPU核心数、内存大小】

【优化方向】

方向1：向量化（用NumPy代替循环）
```python
# 慢速代码
for i in range(len(data)):
    result[i] = data[i] * 2

# 优化代码
result = data * 2
```

方向2：使用更高效的数据结构
```python
# 慢速：列表查找
values = [1, 2, 3, 4, 5]
if 3 in values:
    pass

# 优化：使用集合
values_set = {1, 2, 3, 4, 5}
if 3 in values_set:
    pass
```

方向3：批量处理代替逐个处理
```python
# 慢速：逐行处理
for i in range(len(df)):
    process_row(df.iloc[i])

# 优化：向量化操作
df.apply(process_function, axis=1)
```

方向4：并行处理
```python
from multiprocessing import Pool

def process_data(data_chunk):
    # 处理数据块的函数
    return processed_data

# 创建进程池
with Pool(processes=4) as pool:
    results = pool.map(process_data, data_chunks)
```

【完整优化Prompt】
```
请优化以下代码性能：

【代码】
```python
import pandas as pd
import numpy as np

# 慢速代码
df = pd.read_csv('large_file.csv')
result = []
for i in range(len(df)):
    row = df.iloc[i]
    if row['value'] > 100:
        result.append(row['value'] * 2)
result = pd.Series(result)
```

【数据信息】
文件大小：1GB
行数：1000万行
列数：20

【优化目标】
- 运行时间：从30分钟降到5分钟以内
- 内存使用：不超过8GB

【要求】
1. 代码优化：使用pandas向量化操作
2. 分块读取：使用chunksize参数
3. 并行处理：multiprocessing
4. 类型优化：指定dtype减少内存
5. 提供优化前后的性能对比

【期望代码】
```python
# 优化版本
import pandas as pd
import numpy as np
from multiprocessing import Pool

def process_chunk(chunk):
    chunk = chunk[chunk['value'] > 100]
    return chunk['value'] * 2

# 分块读取和处理
chunksize = 100000
results = []
for chunk in pd.read_csv('large_file.csv', chunksize=chunksize):
    result = process_chunk(chunk)
    results.append(result)

final_result = pd.concat(results)
```
```
```

### 内存不足优化完整Prompt

```
我的代码内存不足，请优化。

【错误信息】
MemoryError: Unable to allocate X GiB for an array with shape ...

【代码信息】
【代码】

【数据规模】
数据形状：【行数×列数】
数据类型：float64
可用内存：【8GB】

【优化策略】

策略1：使用生成器（推荐）
```python
# 慢速：一次性读取
data = pd.read_csv('large_file.csv')

# 优化：分块读取
chunk_iter = pd.read_csv('large_file.csv', chunksize=10000)
for chunk in chunk_iter:
    process(chunk)
    # 处理完就释放内存
```

策略2：指定dtype
```python
# 默认：object、float64（占用8字节）
# 优化：使用较小的数据类型
dtypes = {
    'id': 'int32',
    'age': 'int16',
    'price': 'float32',
    'category': 'category'
}
df = pd.read_csv('file.csv', dtype=dtypes)
```

策略3：及时释放内存
```python
import gc

# 处理完数据后
del df
gc.collect()
```

【完整优化Prompt】
```
请优化以下代码的内存使用：

【代码】
【你的代码】

【要求】
1. 识别内存占用的主要原因
2. 提供3-5个优化方案
3. 对每个方案解释原理
4. 提供完整的优化代码
5. 估算内存节省

【期望输出】
方案1：使用生成器分块处理
  - 节省内存：【估算】
  - 实现方法：【代码】

方案2：优化数据类型
  - 节省内存：【估算】
  - 实现方法：【代码】

方案3：及时释放内存
  - 节省内存：【估算】
  - 实现方法：【代码】
```
```

---

## 🔍 场景3: 调试技巧

### 添加调试信息完整模板

```
请在代码中添加调试信息。

【代码】
【你的代码】

【调试位置】
- 函数入口
- 循环内部
- 条件分支
- 异常处理块

【调试信息类型】

1. 基础信息
   - 变量值：`print(f"x={x}, y={y}")`
   - 变量类型：`print(f"type(x)={type(x)}")`
   - 变量形状：`print(f"shape={x.shape}")`

2. 执行进度
   ```python
   for i in range(len(data)):
       if i % 1000 == 0:
           print(f"处理进度：{i}/{len(data)}")
   ```

3. 时间测量
   ```python
   import time
   
   start_time = time.time()
   # 你的代码
   end_time = time.time()
   print(f"运行时间：{end_time - start_time:.2f}秒")
   ```

4. 内存使用
   ```python
   import psutil
   
   process = psutil.Process()
   print(f"内存使用：{process.memory_info().rss / 1024 / 1024:.2f} MB")
   ```

5. 条件分支验证
   ```python
   if condition:
       print("条件满足")
   else:
       print("条件不满足")
   ```

【完整调试模板】
```
请在以下代码的关键位置添加调试信息：

【代码】
```python
def process_data(data):
    print(f"[DEBUG] 输入数据形状: {data.shape}")
    
    # 处理步骤1
    data_cleaned = remove_outliers(data)
    print(f"[DEBUG] 清洗后形状: {data_cleaned.shape}")
    
    # 处理步骤2
    result = normalize(data_cleaned)
    print(f"[DEBUG] 处理后形状: {result.shape}")
    
    return result

for i in range(len(data)):
    if i % 100 == 0:
        print(f"[DEBUG] 处理进度：{i}/{len(data)}")
    processed = process_data(data[i])
```

【输出要求】
1. 在函数入口显示输入信息
2. 在关键步骤显示中间结果
3. 显示处理进度
4. 捕获异常信息
5. 使用logging模块（比print更专业）

【使用logging的示例】
```python
import logging

# 配置logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    filename='debug.log'
)

logger = logging.getLogger(__name__)
logger.debug("调试信息")
logger.info("普通信息")
logger.warning("警告信息")
logger.error("错误信息")
```
```

### 逐步调试完整模板

```
请帮我逐步调试代码，找出错误位置。

【代码】
【你的完整代码】

【方法1：二分法调试】

步骤1：注释代码后半部分
步骤2：运行前半部分
步骤3：逐步取消注释，缩小错误范围

【方法2：断点调试】

使用IDE调试器：
```python
import pdb; pdb.set_trace()

# 在需要暂停的位置添加断点
pdb.set_trace()

# 或使用breakpoint()（Python 3.7+）
breakpoint()  # 在此行暂停
```

【方法3：隔离问题

创建最小可复现示例：
```python
# 简化到最简单的case
test_data = [1, 2, 3]
result = your_function(test_data)
```

【完整调试Prompt】
```
请调试以下函数，找出错误并修复：

【函数代码】
```python
def predict(X, model):
    # 你的预测函数
    y_pred = model.predict(X)
    return y_pred
```

【调用代码】
```python
X_test = ...
model = ...
y_pred = predict(X_test, model)
```

【调试步骤】
1. 检查输入：X_test.shape, X_test.dtype
2. 检查模型：model类型、参数
3. 检查输出：y_pred.shape, y_pred.dtype
4. 检查中间值：添加print语句
5. 检查返回值

【要求】
1. 显示每步的输入输出
2. 识别错误的准确位置
3. 提供修复后的代码
4. 添加错误处理
```
```

---

## 🛠️ 场景4: 常见特定错误修复

### Pandas特定错误修复

```
【错误1】SettingWithCopyWarning
【错误信息】
SettingWithCopyWarning: A value is trying to be set on a copy...

【原因】
Pandas链式赋值可能返回视图而非副本

【修复】
```python
# 方法1：使用.copy()
df['new_col'] = df['old_col'].copy()
df.loc[:, 'new_col'] = df['old_col']  # 使用loc

# 方法2：禁用警告
pd.set_option('mode.chained_assignment', 'raise')
```

【错误2】DataFrame浮点数精度
```
【问题】
显示很多.000000000001

【修复】
```python
# 显示时控制小数位数
pd.set_option('display.float_format', '{:.2f}'.format)

# 四舍五入
df.round(2)
```
```

### Matplotlib特定错误修复

```
【错误1】中文乱码
【错误】
图表中文字显示为方框

【原因】
缺少中文字体配置

【修复】
```python
import matplotlib.pyplot as plt

# 设置中文字体
plt.rcParams['font.sans-serif'] = ['Arial Unicode MS', 'SimHei']
plt.rcParams['axes.unicode_minus'] = False
```

【错误2】图表不显示
【原因】
没有调用plt.show()

【修复】
```python
plt.savefig('figure.png')
plt.show()  # 必须调用
plt.close()  # 关闭图形
```

【错误3】子图重叠
【原因】
布局未调整或subplots_adjust参数不对

【修复】
```python
plt.tight_layout()
# 或
plt.subplots_adjust(left=0.1, bottom=0.1, right=0.95, top=0.95)
```
```

### Scikit-learn特定错误修复

```
【错误1】DataConversionWarning
【错误信息】
DataConversionWarning: A column-vector y was passed

【原因】
标签格式不正确

【修复】
```python
# 确保 y 是一维数组
y = y.values.ravel()  # DataFrame转一维
y = y.astype(int)  # 确保是整数类型
```

【错误2】DimensionalityMismatch
【错误信息】
Dimensionality mismatch: X has 10 features, but y has 20 rows

【原因】
特征数量不匹配

【修复】
```python
print(f"X shape: {X.shape}")
print(f"y shape: {y.shape}")

# 修复：确保X和y的样本数一致
assert X.shape[0] == len(y)
```
```

---

## 💡 场景5: 代码质量提升

### 代码重构完整模板

```
请帮我重构代码，提高代码质量。

【原始代码】
【你的代码】

【重构目标】
1. 提高可读性
2. 增强复用性
3. 添加文档字符串
4. 遵循PEP8规范
5. 添加类型提示

【重构步骤】

步骤1：函数化
```python
# 重构前
for i in range(len(data)):
    result = data[i] * 2
    result = result + 10

# 重构后
def process_data(data):
    """处理数据的函数
    
    Args:
        data: 输入数据
        
    Returns:
        处理后的数据
    """
    return data * 2 + 10
```

步骤2：添加类型提示
```python
from typing import Union, List

def process_data(data: Union[np.ndarray, List]) -> np.ndarray:
    """处理数据的函数
    
    Args:
        data: 输入数据
        
    Returns:
        处理后的数据
    """
    if isinstance(data, list):
        data = np.array(data)
    return data * 2 + 10
```

步骤3：添加文档字符串
```python
def train_model(X_train, y_train, n_estimators=100):
    """
    训练随机森林模型
    
    Parameters:
        X_train (array-like): 训练特征
        y_train (array-like): 训练标签
        n_estimators (int): 树的数量
        
    Returns:
        model: 训练好的模型
        score: 模型得分
    """
    from sklearn.ensemble import RandomForestClassifier
    
    model = RandomForestClassifier(
        n_estimators=n_estimators,
        random_state=42
    )
    model.fit(X_train, y_train)
    score = model.score(X_train, y_train)
    
    return model, score
```

步骤4：添加异常处理
```python
def safe_divide(a, b):
    """安全除法，避免除零错误"""
    try:
        return a / b
    except ZeroDivisionError:
        print(f"警告：除零错误，返回0")
        return 0
```

【完整重构Prompt】
```
请重构以下代码：

【代码】
【你的原始代码】

【重构要求】
1. 提取函数
2. 添加类型提示
3. 添加文档字符串
4. 遵循PEP8规范
5. 添加异常处理
6. 添加单元测试示例
7. 优化性能（如果需要）

【输出要求】
1. 重构后的代码
2. 每个函数的说明
3. 重构前对比
4. 改进说明
```
```

---

## 🧪 场景6: 单元测试创建

### 单元测试完整模板

```
请为以下函数创建单元测试。

【函数代码】
```python
def calculate_bmi(weight, height):
    """
    计算BMI指数
    
    Args:
        weight: 体重（公斤）
        height: 身高（米）
    
    Returns:
        BMI指数
    """
    return weight / (height ** 2)
```

【测试要求】

测试用例1：正常情况
```python
def test_bmi_normal():
    # 输入：体重70kg，身高1.75m
    # 预期：BMI = 22.86
    assert abs(calculate_bmi(70, 1.75) - 22.86) < 0.01
```

测试用例2：边界情况
```python
def test_bmi_edge():
    # 测试极小值
    assert calculate_bmi(1, 1) == 1.0
    
    # 测试零值
    try:
        calculate_bmi(0, 1.75)
        assert False, "应该抛出异常"
    except:
        pass
```

测试用例3：异常情况
```python
def test_bmi_invalid():
    # 测试负数
    try:
        calculate_bmi(-70, 1.75)
        assert False, "应该抛出异常"
    except ValueError:
        pass
```

【完整单元测试Prompt】
```
请为calculate_bmi函数创建完整的单元测试。

【函数定义】
【函数代码】

【测试框架】
使用pytest或unittest

【测试内容】
1. 正常值测试
2. 边界值测试
3. 异常值测试
4. 类型检查测试
5. 性能测试（大数据量）

【代码要求】
使用pytest
完整的测试文件
包含测试前后的setup/teardown
参数化测试
断言清晰
覆盖率>80%

【输出要求】
1. 完整的测试文件
2. 测试用例说明
3. 运行测试的命令
4. 测试报告示例
```
```
```

请使用pytest创建单元测试文件。

【函数】
```python
def calculate_bmi(weight, height):
    """计算BMI指数"""
    return weight / (height ** 2)
```

【测试要求】
使用pytest框架

测试用例：
1. 正常值测试
2. 边界值测试（0, 极小值）
3. 异常值测试（负数、0值）
4. 类型检查（整数、浮点数）
5. 性能测试（大数据）

【要求】
1. 测试文件名：test_bmi.py
2. 包含所有测试用例
3. 每个测试有清晰的文档
4. 包含setup和teardown
5. 参数化测试
6. 运行命令：pytest test_bmi.py

【输出】
提供完整的pytest代码文件
```
```

---

## 🎯 场景7: 错误预防最佳实践

### 预防性编程完整模板

```
请按照最佳实践重写以下代码，增加错误预防措施。

【原始代码】
【你的代码】

【预防措施】

措施1：输入验证
```python
def process_data(data):
    """处理数据，包含完整的输入验证"""
    # 检查数据类型
    if not isinstance(data, (list, np.ndarray, pd.DataFrame)):
        raise TypeError("数据必须是list、numpy数组或DataFrame")
    
    # 检查数据非空
    if isinstance(data, list) and len(data) == 0:
        raise ValueError("数据不能为空")
    
    # 检查数值范围（如果适用）
    if isinstance(data, np.ndarray):
        if np.any(np.isnan(data)):
            raise ValueError("数据包含NaN值")
```

措施2：边界条件检查
```python
def division(a, b):
    """安全除法"""
    if b == 0:
        raise ValueError("除数不能为零")
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise TypeError("操作数必须是数值类型")
    return a / b
```

措施3：日志记录
```python
import logging

logging.basicConfig(
    filename='app.log',
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

logger = logging.getLogger(__name__)

def process(data):
    logger.info(f"开始处理数据，形状：{data.shape}")
    # 处理逻辑
    logger.info("数据处理完成")
    return result
```

措施4：异常处理
```python
try:
    result = risky_operation()
except SpecificError as e:
    logger.error(f"发生错误：{e}")
    # 使用默认值或备用方案
    result = default_value
except Exception as e:
    logger.critical(f"未预期的错误：{e}")
    raise
```

【完整Prompt示例】
```
请重写以下代码，添加完整的错误预防措施：

【原始代码】
【你的代码】

【预防措施清单】
- [ ] 输入验证（类型、范围、非空）
- [ ] 边界条件检查
- [ ] 异常处理
- [ ] 日志记录
- [ ] 单元测试
- [ ] 类型提示
- [ ] 文档字符串
- [ ] 参数验证

【要求】
1. 提供完整的改进代码
2. 每个预防措施都有说明
3. 代码可读性高
4. 包含使用示例
```
```

---

## 📋 快速修复速查表

| 错误类型 | 快速检查 | 常见原因 | 快速修复 |
|---------|---------|---------|---------|
| TypeError | 检查类型 | 类型不匹配 | 使用类型转换 |
| ValueError | 检查数值 | 越出范围 | 调整范围 |
| KeyError | 检查键名 | 键名错误 | 检查列名/字典键 |
| IndexError | 检查索引 | 索引越界 | 调整索引范围 |
| ImportError | 检查导入 | 未安装库 | pip install |
| AttributeError | 检查属性 | 属性不存在 | 检查对象类型 |
| MemoryError | 检查内存 | 数据太大 | 分块处理、优化类型 |
| RuntimeError | 检查逻辑 | 逻辑错误 | 添加条件判断 |

---

## 🚀 紧急修复模板

### 紧急修复完整模板

```
【紧急修复请求】

【问题描述】
【简要描述问题，2-3句话】

【代码/错误】
【粘贴代码或错误信息】

【目标】
【期望的结果】

【要求】
- 快速识别问题
- 提供修复方案
- 提供修复后的代码
- 解释修复原理

【示例】
```
【问题描述】
我的模型准确率只有60%，远低于预期。

【模型类型】
RandomForestClassifier
数据：10000行×20列
目标：二分类

【要求】
快速提供3-5个改进方向和具体的代码实现。
```
```

---

## 💡 实用调试技巧

### 打印调试技巧

```
【技巧1：选择性打印】
```python
DEBUG = True  # 全局调试开关

if DEBUG:
    print(f"变量x的值: {x}")
    print(f"变量y的值: {y}")
```

【技巧2：格式化输出
```python
print(f"X: {x.shape}, dtype: {x.dtype}")
print(f"y: {y[:10]}... (显示前10个元素)")
```

【技巧3：使用pprint
```python
from pprint import pprint
pprint(large_object)  # 美观输出复杂数据
```

【技巧4：使用logging
```python
logging.basicConfig(level=logging.DEBUG)
logger.debug("调试信息")
logger.info("普通信息")
```
```

### 断点调试技巧

```python
# 方法1：硬编码断点
import pdb; pdb.set_trace()

# 方法2：条件断点
import pdb; pdb.set_trace()

# 方法3：IPython调试（推荐）
# 在IPython中使用%%debug魔法命令
```

### 性能分析技巧

```python
import time
import psutil

# 时间测量
start_time = time.time()
# 你的代码
end_time = time.time()
print(f"运行时间: {end_time - start_time:.2f}秒")

# 内存监控
process = psutil.Process()
print(f"内存使用: {process.memory_info().rss / 1024 / 1024:.2f} MB")
```

---

**文件结束**

本文件涵盖了代码调试和修复的所有主要场景，包括错误修复、性能优化、调试技巧、单元测试、错误预防等，每个模板都包含详细的诊断步骤和解决方案。
